pump_scheme_decisions <- x$input$demand_reduction_schemes %>%
group_by(area) %>%
summarise(total_available_schemes = n()) %>%
ungroup()
list(
upper = pump_scheme_decisions$total_available_schemes,
lower = rep(1, length(
pump_scheme_decisions$total_available_schemes
)),
decision_name = paste0(pump_scheme_decisions$area, "_demand_scheme")
)
}
pump_scheme_decisions <-
make_pump_scheme_decisions(pump_optimisation)
pump_scheme_decisions
make_pump_output_decisions <- function(x) {
upper <- x$input$pump_details$pump_max_output
lower <- x$input$pump_details$pump_min_output
decision_name <- x$input$pump_details$pump
list(upper = upper,
lower = lower,
decision_name = decision_name)
}
pump_output_decisions <-
make_pump_output_decisions(pump_optimisation)
pump_output_decisions
dev_decision_bounds <- function(x) {
pump_scheme_decisions <-
make_pump_scheme_decisions(pump_optimisation)
pump_scheme_decisions
pump_output_decisions <-
make_pump_output_decisions(pump_optimisation)
pump_output_decisions
# concat decisions
x <- list(pump_scheme_decisions,
pump_output_decisions)
concat_decisions(x)
}
dev_decision_bounds(pump_optimisation)
# Add to genga
pump_optimisation <-
add_decision_bound_function(pump_optimisation, dev_decision_bounds)
pump_optimisation
# Chunk 6
# Develop function to apply decisions and produce outputs
decisions <- make_random_decisions(pump_optimisation)
#decisions
dev_evaluate <- function(x, decisions) {
#browser()
# Get decision bounds lengths
decision_bounds_lengths <- get_decision_bounds(x)$lengths
# Split decision stream into schemes and pumps
scheme_decisions <- decisions[1:decision_bounds_lengths[1]]
pump_decisions <-
decisions[decision_bounds_lengths[1] + 1:decision_bounds_lengths[2]]
# Apply scheme decisions
scheme_decisions <- round(scheme_decisions, 0)
selected_schemes <-
split(x$input$demand_reduction_schemes,
x$input$demand_reduction_schemes$area)
scheme_area_length <- lapply(selected_schemes, nrow)
scheme_area_decision_logicals <- lapply(scheme_area_length, logical)
set_to_true <- function(x, index){
x[index] <- TRUE
x
}
scheme_area_decision_logicals <- mapply(set_to_true,
x = scheme_area_decision_logicals,
index = scheme_decisions)
selected_schemes <- mapply(function(x, y) mutate(x, selected = y),
x = selected_schemes,
y = scheme_area_decision_logicals,
SIMPLIFY = FALSE
)
schemes_selected_summary <- selected_schemes %>%
bind_rows() %>%
mutate(selected = as.numeric(selected)) %>%
select(area, name, selected) %>%
gather(output_name, output_value, -area, -name)
selected_schemes <- selected_schemes %>%
bind_rows() %>%
filter(selected) %>%
select(-selected)
demand_schemes <- x$input$area_demand %>%
left_join(selected_schemes, by = "area") %>%
mutate(post_scheme_demand = demand + demand_reduction) %>%
select(area, name,  cost, post_scheme_demand) %>%
gather(output_name, output_value,-area,-name)
demand_schemes_summary <- demand_schemes %>%
group_by(area, output_name) %>%
summarise(output_value = sum(output_value))
# Calculate pump level outputs
pump_calc <- x$input$pump_details %>%
left_join(x$input$pump_costs, by = c("area", "pump")) %>%
# Add decisions
mutate(decision = pump_decisions) %>%
# Calculate costs
mutate(cost = pump_cost_intercept + decision ^ pump_cost_exp)
# pump_calc
pump_level_outputs <- pump_calc %>%
select(pump,
output = decision,
cost) %>%
mutate(cost_per_unit = cost / output) %>%
gather(output_name, output_value,-pump)
#pump_level_outputs
area_supply <- pump_calc %>%
group_by(area) %>%
summarise(total_supply = sum(decision)) %>%
ungroup()
headroom <- x$input$area_demand %>%
left_join(selected_schemes, by = "area") %>%
left_join(area_supply, by = "area") %>%
mutate(headroom = total_supply - (demand - demand_reduction)) %>%
select(area, headroom) %>%
gather(output_name, output_value,-area)
outputs <- list(headroom = headroom,
pump_level_outputs = pump_level_outputs,
schemes_selected_summary = schemes_selected_summary)
#outputs
}
# Test outputs are correct
(dev_evaluate(pump_optimisation, decisions))
# Add to genga
pump_optimisation <- add_evaluation_function(pump_optimisation, dev_evaluate)
pump_optimisation <- evaluate(pump_optimisation, decisions)
# Test evaluation
pump_optimisation <- evaluate(pump_optimisation, decisions)
pump_optimisation$output
# Chunk 7
# Make blank config
opt_config <- make_blank_optimisation_config(pump_optimisation)
opt_config
# Set headroom targets
opt_config$headroom$target_value <- 0
opt_config$headroom$target_type <- "min"
opt_config$headroom$weight <- 100000
# Set goals to minimise costs
opt_config$pump_level_outputs <- opt_config$pump_level_outputs %>%
mutate(target_type = ifelse(output_name == "cost", "goal", NA),
weight = ifelse(output_name == "cost", 1, NA))
# Add config to genga
pump_optimisation <- add_optimisation_config(pump_optimisation, opt_config)
pump_optimisation
opt_config
pump_optimisation <- optimise(pump_optimisation,
#monitor = plot,
#parallel = 7,
maxiter = 10,
run = 250,
popSize = 50)
pump_optimisation$output
# Develop function to apply decisions and produce outputs
decisions <- make_random_decisions(pump_optimisation)
#decisions
dev_evaluate <- function(x, decisions) {
#browser()
# Get decision bounds lengths
decision_bounds_lengths <- get_decision_bounds(x)$lengths
# Split decision stream into schemes and pumps
scheme_decisions <- decisions[1:decision_bounds_lengths[1]]
pump_decisions <-
decisions[decision_bounds_lengths[1] + 1:decision_bounds_lengths[2]]
# Apply scheme decisions
scheme_decisions <- round(scheme_decisions, 0)
selected_schemes <-
split(x$input$demand_reduction_schemes,
x$input$demand_reduction_schemes$area)
scheme_area_length <- lapply(selected_schemes, nrow)
scheme_area_decision_logicals <- lapply(scheme_area_length, logical)
set_to_true <- function(x, index){
x[index] <- TRUE
x
}
scheme_area_decision_logicals <- mapply(set_to_true,
x = scheme_area_decision_logicals,
index = scheme_decisions)
selected_schemes <- mapply(function(x, y) mutate(x, selected = y),
x = selected_schemes,
y = scheme_area_decision_logicals,
SIMPLIFY = FALSE
)
schemes_selected_summary <- selected_schemes %>%
bind_rows() %>%
mutate(selected = as.numeric(selected)) %>%
select(area, name, selected) %>%
gather(output_name, output_value, -area, -name)
selected_schemes <- selected_schemes %>%
bind_rows() %>%
filter(selected) %>%
select(-selected)
demand_schemes <- x$input$area_demand %>%
left_join(selected_schemes, by = "area") %>%
mutate(post_scheme_demand = demand + demand_reduction) %>%
select(area, name,  cost, post_scheme_demand) %>%
gather(output_name, output_value,-area,-name)
demand_schemes_summary <- demand_schemes %>%
group_by(area, output_name) %>%
summarise(output_value = sum(output_value))
# Calculate pump level outputs
pump_calc <- x$input$pump_details %>%
left_join(x$input$pump_costs, by = c("area", "pump")) %>%
# Add decisions
mutate(decision = pump_decisions) %>%
# Calculate costs
mutate(cost = pump_cost_intercept + decision ^ pump_cost_exp)
# pump_calc
pump_level_outputs <- pump_calc %>%
select(pump,
output = decision,
cost) %>%
mutate(cost_per_unit = cost / output) %>%
gather(output_name, output_value,-pump)
#pump_level_outputs
area_supply <- pump_calc %>%
group_by(area) %>%
summarise(total_supply = sum(decision)) %>%
ungroup()
headroom <- x$input$area_demand %>%
left_join(selected_schemes, by = "area") %>%
left_join(area_supply, by = "area") %>%
mutate(headroom = total_supply - (demand - demand_reduction)) %>%
select(area, headroom) %>%
gather(output_name, output_value,-area)
outputs <- list(headroom = headroom,
pump_level_outputs = pump_level_outputs,
schemes_selected_summary = schemes_selected_summary)
#outputs
}
# Test outputs are correct
(dev_evaluate(pump_optimisation, decisions))
# Add to genga
pump_optimisation <- add_evaluation_function(pump_optimisation, dev_evaluate)
pump_optimisation <- evaluate(pump_optimisation, decisions)
# Test evaluation
pump_optimisation <- evaluate(pump_optimisation, decisions)
pump_optimisation$output
# Make blank config
opt_config <- make_blank_optimisation_config(pump_optimisation)
opt_config
# Set headroom targets
opt_config$headroom$target_value <- 0
opt_config$headroom$target_type <- "min"
opt_config$headroom$weight <- 100000
# Set goals to minimise costs
opt_config$pump_level_outputs <- opt_config$pump_level_outputs %>%
mutate(target_type = ifelse(output_name == "cost", "goal", NA),
weight = ifelse(output_name == "cost", 1, NA))
# Add config to genga
pump_optimisation <- add_optimisation_config(pump_optimisation, opt_config)
pump_optimisation
opt_config
pump_optimisation <- optimise(pump_optimisation,
#monitor = plot,
#parallel = 7,
maxiter = 10,
run = 250,
popSize = 50)
pump_optimisation$output
pump_optimisation
pump_optimisation$output
opt_config
opt_config$pump_level_outputs %>%
mutate(target_type = ifelse(output_name == "cost", "goal", NA),
weight = ifelse(output_name == "cost", 1, NA))
# Make blank config
opt_config <- make_blank_optimisation_config(pump_optimisation)
opt_config
# Set headroom targets
opt_config$headroom$target_value <- 0
opt_config$headroom$target_type <- "min"
opt_config$headroom$weight <- 100000
# Set goals to minimise costs
opt_config$pump_level_outputs <- opt_config$pump_level_outputs %>%
mutate(target_type = ifelse(output_name == "cost", "goal", NA),
weight = ifelse(output_name == "cost", 1, NA))
# Add config to genga
pump_optimisation <- add_optimisation_config(pump_optimisation, opt_config)
pump_optimisation
opt_config
library(dplyr)
library(tidyr)
library(data.table)
library(dplyr)
library(plyr)
library(sp)
library(sf)
library(raster)
library(maptools)
library(units)
library(tmap)
library(ggplot2)
library(rgdal)
library(gbm)
library(DescTools)
library(party)
library(caret)
library(tictoc)
library(purrr)
s24 <- st_read("G:\\Desktop\\STW PDaS\\S24 PDaS Filtered GIS\\STW_S24_Pipes.shp")
str(s24)
s24_confirmed <- s24 %>% filter(Pop_Dim == "A") %>%
filter(Pop_Mat == "A") %>%
filter(Pop_Yer != "C")
s24_confirmed <- s24_confirmed[!duplicated(s24_confirmed$Tag),]
summary(s24_confirmed)
s24_confirmed_1 <- as.data.frame(s24_confirmed) %>%
dplyr::select(Tag,County,Length,Tp_prps,Bndd_Mt,Bndd_Dm,Bndd_Yr,geometry) %>%
dplyr::rename(pipe_typ = Tp_prps) %>%
dplyr::rename(pipe_diam = Bndd_Dm) %>%
dplyr::rename(id = Tag) %>%
dplyr::rename(length = Length) %>%
dplyr::rename(pipe_mat = Bndd_Mt) %>%
dplyr::rename(Age = Bndd_Yr) %>%
mutate(Age = 2020 - as.numeric(as.character(Age)))
# s24_confirmed_2 <- s24_confirmed_1 %>%
#   mutate_at(c(3:5,7:8),as.character)
#deselct geomerty and transform length to factor
s24_confirmed_2 <- s24_confirmed_1 %>%
mutate(lengthband = as.factor(paste("band",round(length/20)))) %>%
mutate(Age = as.factor(Age)) %>%
dplyr::select(-length)
#split data for ML
set.seed(5)
train.base <- sample(1:nrow(s24_confirmed_2),(nrow(s24_confirmed_2)*0.85),replace = FALSE)
traindata.base <- s24_confirmed_2[train.base, ]
testdata.base <- s24_confirmed_2[-train.base, ]
traindata.base
str(traindata.base)
dplyr::select(-c(length,geometry)
)
# s24_confirmed_2 <- s24_confirmed_1 %>%
#   mutate_at(c(3:5,7:8),as.character)
#deselct geomerty and transform length to factor
s24_confirmed_2 <- s24_confirmed_1 %>%
mutate(lengthband = as.factor(paste("band",round(length/20)))) %>%
mutate(Age = as.factor(Age)) %>%
dplyr::select(-c(length,geometry))
s24_confirmed_2
#split data for ML
set.seed(5)
train.base <- sample(1:nrow(s24_confirmed_2),(nrow(s24_confirmed_2)*0.85),replace = FALSE)
traindata.base <- s24_confirmed_2[train.base, ]
testdata.base <- s24_confirmed_2[-train.base, ]
#cl <- makePSOCKcluster(6)
#registerDoParallel(cl) #start parallelisation
rf.fit3 <- cforest(pipe_diam ~ County + lengthband + Age, data = traindata.base, controls = cforest_unbiased(ntree = 50, mtry = 4))
rf.pred3 <- predict(rf.fit3,newdata = testdata.base, type = 'response')
caret::confusionMatrix(rf.pred3, testdata.base$pipe_diam)
cforestStats(rf.fit3)
####################################### Test confidence in old s24 ###################################################
s24 <- st_read("G:\\Desktop\\STW PDaS\\S24 PDaS Filtered GIS\\Joined S24\\Joined_S24.shp")
####################################### Test confidence in old s24 ###################################################
s24 <- st_read("I:\\Projects\\Client\\1883\\Analytics\\S24 PDaS Filtered GIS\\Joined S24\\Joined_S24.shp")
str(s24)
summary(s24)
s24_confirmed <- s24
s24_confirmed <- s24_confirmed[!duplicated(s24_confirmed$Tag),]
summary(s24_confirmed)
s24_confirmed %>% filter(Length > 100)
Address_2 <- st_read("I:\\Projects\\Client\\1883\\Analytics\\2020-03-10 TW Data\\ABP_PDaS\\Address\\Address.shp")
library(tidyr)
library(data.table)
library(dplyr)
library(plyr)
library(sp)
library(sf)
library(raster)
library(maptools)
library(units)
library(tmap)
library(ggplot2)
library(rgdal)
library(gbm)
library(DescTools)
library(party)
library(caret)
library(tictoc)
library(purrr)
Address_2 <- st_read("I:\\Projects\\Client\\1883\\Analytics\\2020-03-10 TW Data\\ABP_PDaS\\Address\\Address.shp")
Historic_2 <- st_read("I:\\Projects\\Client\\1883\\Analytics\\2020-03-10 TW Data\\ABP_PDaS\\Historic Address\\HistoricAddress.shp")
Historic_2
cred <- git2r::cred_user_pass(rstudioapi::askForPassword("username"),
rstudioapi::askForPassword("Password"))
devtools::install_git("https://gitlab.com/tayoso2/sfxtra.git",credentials = cred)
library(sfXtra)
library(doMC)
install.packages("doMC")
library("doMC")
# load the data
ele1_load <- readRDS("C:/Users/TOsosanya/Desktop/ele1.rds")
blockage_sf_load <- readRDS("C:/Users/TOsosanya/Desktop/blockage_sf.rds")
pipe_sf_load <- readRDS("C:/Users/TOsosanya/Desktop/pipe_sf.rds")
# test the functions
GetElevation(x = ele1_load,AssetID = "Asset_Number",src = "aws")
FindNearest(blockage_sf_load,pipe_sf_load[1:10,])
cred <- git2r::cred_user_pass(rstudioapi::askForPassword("username"),
rstudioapi::askForPassword("Password"))
devtools::install_git("https://gitlab.com/tayoso2/sfxtra.git",credentials = cred)
cred <- git2r::cred_user_pass(rstudioapi::askForPassword("username"),
rstudioapi::askForPassword("Password"))
devtools::install_git("https://gitlab.com/tayoso2/sfxtra.git",credentials = cred)
# load the data
ele1_load <- readRDS("C:/Users/TOsosanya/Desktop/ele1.rds")
blockage_sf_load <- readRDS("C:/Users/TOsosanya/Desktop/blockage_sf.rds")
pipe_sf_load <- readRDS("C:/Users/TOsosanya/Desktop/pipe_sf.rds")
# test the functions
GetElevation(x = ele1_load,AssetID = "Asset_Number",src = "aws")
FindNearest(blockage_sf_load,pipe_sf_load[1:10,])
# first step of creating the package folder
library("devtools")
install.packages("devtools")
install.packages("devtools")
# first step of creating the package folder
library("devtools")
install.packages("devtools")
# first step of creating the package folder
library("devtools")
install.packages("devtools")
# first step of creating the package folder
library("devtools")
install.packages("cli")
library("devtools")
install.packages("devtools")
library("devtools")
install.packages("assertthat")
library("devtools")
install.packages("crayon")
library("devtools")
library("Rcpp")
install.packages("Rcpp")
library("devtools")
install.packages("fansi")
library("devtools")
install.packages("ellipsis")
library("devtools")
install.packages("memoise")
library("devtools")
install.packages("digest")
library("devtools")
install.packages("R6")
library("devtools")
install.packages("ps")
library("devtools")
install.packages("prettyunits")
library("devtools")
install.packages("pkgload")
library("devtools")
install.packages("withr")
library("devtools")
install.packages("desc")
library("devtools")
install.packages("rprojroot")
library("devtools")
install.packages("backports")
library("devtools")
install.packages("magrittr")
library("devtools")
install.packages("sessioninfo")
library("devtools")
library(roxygen2)
install.packages("roxygen2")
install.packages("tidyverse")
install.packages("plyr")
install.packages("sp")
install.packages("sf")
install.packages("data.table")
library(roxygen2)
install.packages("stringr")
library(roxygen2)
install.packages("stringi")
library(roxygen2)
install.packages("knitr")
library(roxygen2)
install.packages("knitr",dependencies = TRUE)
install.packages("roxygen",dependencies = TRUE)
install.packages("roxygen2",dependencies = TRUE)
library(roxygen2)
install.packages("xfun",dependencies = TRUE)
library(roxygen2)
install.packages("purrr",dependencies = TRUE)
library(roxygen2)
setwd("C:\\Users\\TOsosanya\\Desktop")
create("awapi")
# second step of creating the .rd of the functions in man folder
setwd("C:\\Users\\TOsosanya\\Desktop\\awapi\\R")
devtools::document()
# second step of creating the .rd of the functions in man folder
setwd("C:\\Users\\TOsosanya\\Desktop\\awapi\\R")
devtools::document()
install.packages("commonmark",dependencies = TRUE)
devtools::document()
# install from git
cred <- git2r::cred_user_pass(rstudioapi::askForPassword("username"),
rstudioapi::askForPassword("Password"))
devtools::install_git("https://gitlab.com/tayoso2/awapi.git",credentials = cred)
devtools::install_git("https://gitlab.com/tayoso2/awapi.git",credentials = cred)
library(awapi)
# API Key -----------------------------------------------------------------
aw_set_api_key("UMGhuFhSoPE5japY8orbqC06F0oMZquv")
aw_is_api_key_set() # should yield TRUE else set key again
aw_check_status_code(lat = 53.362893,lon = -2.4247147)
install.packages("curl",dependencies = TRUE)
aw_check_status_code(lat = 53.362893,lon = -2.4247147)
library("httr")
aw_check_status_code(lat = 53.362893,lon = -2.4247147)
devtools::install_git("https://gitlab.com/tayoso2/awapi.git",credentials = cred)
install.packages("Rtools",dependencies = TRUE)
devtools::install_git("https://gitlab.com/tayoso2/awapi.git",credentials = cred)
library("Rtools")
library("Rtool")
install.packages("Rtools")
